# 智播农链——技术架构设计文档

## 项目目录结构

```
智播农链/
├── app.py                      # Streamlit主应用入口
├── requirements.txt            # 项目依赖包
├── config.py                   # 配置文件
├── README.md                   # 项目说明文档
├── 
├── pages/                      # 页面模块
│   ├── __init__.py
│   ├── dashboard.py           # 首页/仪表板
│   ├── plot_management.py     # 地块管理
│   ├── crop_recommendation.py # 作物推荐
│   ├── crop_detail.py         # 作物详情分析
│   └── data_analysis.py       # 数据分析
│
├── components/                 # UI组件库
│   ├── __init__.py
│   ├── layout.py              # 布局组件
│   ├── navigation.py          # 导航组件
│   ├── cards.py               # 卡片组件
│   ├── charts.py              # 图表组件
│   ├── forms.py               # 表单组件
│   ├── maps.py                # 地图组件
│   ├── sensors.py             # 传感器组件
│   └── widgets.py             # 通用小部件
│
├── data/                       # 数据层
│   ├── __init__.py
│   ├── mock_data.py           # 模拟数据生成
│   ├── data_manager.py        # 数据管理器
│   ├── validators.py          # 数据验证
│   ├── models.py              # 数据模型
│   └── sensor_manager.py      # 传感器数据管理
│
├── algorithms/                 # 算法模块
│   ├── __init__.py
│   ├── recommendation.py      # 推荐算法
│   ├── evaluation.py          # 评估算法
│   ├── prediction.py          # 预测算法
│   ├── analytics.py           # 分析算法
│   └── sensor_fusion.py       # 传感器数据融合
│
├── utils/                      # 工具函数
│   ├── __init__.py
│   ├── helpers.py             # 辅助函数
│   ├── constants.py           # 常量定义
│   └── decorators.py          # 装饰器
│
├── assets/                     # 静态资源
│   ├── css/                   # 样式文件
│   │   ├── main.css
│   │   └── components.css
│   ├── images/                # 图片资源
│   │   ├── logo.png
│   │   └── icons/
│   └── data/                  # 静态数据文件
│       ├── crops.json
│       ├── regions.json
│       ├── weather.json
│       └── sensors.json
│
└── tests/                      # 测试文件
    ├── __init__.py
    ├── test_algorithms.py
    ├── test_data.py
    ├── test_components.py
    └── test_sensors.py
```

## 核心组件设计

### 1. 主应用入口 (app.py)

```python
# 应用配置和路由管理
import streamlit as st
from pages import (
    dashboard, plot_management, crop_recommendation,
    crop_detail, data_analysis
)
from components.navigation import setup_navigation
from components.layout import apply_custom_css
from utils.constants import PAGE_CONFIG

def main():
    # 页面配置
    st.set_page_config(**PAGE_CONFIG)
    
    # 应用自定义CSS
    apply_custom_css()
    
    # 设置导航
    page = setup_navigation()
    
    # 路由到对应页面
    if page == "首页":
        dashboard.show()
    elif page == "地块管理":
        plot_management.show()
    elif page == "作物推荐":
        crop_recommendation.show()
    elif page == "作物详情":
        crop_detail.show()
    elif page == "数据分析":
        data_analysis.show()

if __name__ == "__main__":
    main()
```

### 2. 配置文件 (config.py)

```python
# 系统配置参数
import os

# 应用配置
APP_CONFIG = {
    "title": "智播农链",
    "subtitle": "AI驱动农业全流程数智升级",
    "version": "1.0.0",
    "theme": "light",
    "primary_color": "#90EE90"
}

# 页面配置
PAGE_CONFIG = {
    "page_title": "智播农链 - 作物推荐系统",
    "page_icon": "🌱",
    "layout": "wide",
    "initial_sidebar_state": "expanded"
}

# 推荐算法权重配置
ALGORITHM_WEIGHTS = {
    "environmental": 0.30,  # 环境适应性
    "profit": 0.25,         # 经济效益
    "risk": 0.20,           # 风险评估
    "technical": 0.15,      # 技术难度
    "market": 0.10          # 市场前景
}

# 数据源配置
DATA_SOURCES = {
    "weather_api": "http://api.weather.com",
    "soil_database": "sqlite:///data/soil.db",
    "market_api": "http://api.market.com",
    "expert_knowledge": "data/expert_rules.json"
}

# 传感器配置
SENSOR_CONFIG = {
    "supported_types": ["土壤传感器", "气象传感器", "多合一传感器"],
    "data_update_interval": 300,  # 5分钟
    "data_retention_days": 90,
    "quality_threshold": 0.8,
    "offline_timeout": 1800  # 30分钟
}

# 样式配置
COLORS = {
    "primary": "#90EE90",     # 浅绿色主色
    "secondary": "#98FB98",   # 次要绿色
    "accent": "#00CED1",      # 强调色
    "background": "#F5F5F5",  # 背景色
    "text": "#333333",        # 文字色
    "border": "#E0E0E0"       # 边框色
}
```

### 3. 数据模型 (data/models.py)

```python
# 数据结构定义
from dataclasses import dataclass, field
from typing import List, Dict, Optional
from datetime import datetime

@dataclass
class Location:
    """地理位置信息"""
    latitude: float
    longitude: float
    address: str = ""

@dataclass
class Nutrients:
    """土壤营养成分"""
    nitrogen: float    # 氮含量
    phosphorus: float  # 磷含量
    potassium: float   # 钾含量

@dataclass
class SensorData:
    """传感器数据点"""
    timestamp: datetime
    temperature: float
    humidity: float
    ph_value: float
    salinity: float
    nitrogen: float = 0.0
    phosphorus: float = 0.0
    potassium: float = 0.0

@dataclass
class Sensor:
    """传感器设备信息"""
    sensor_id: str
    sensor_type: str
    plot_id: str
    zone_id: str
    location: Location
    installation_date: datetime
    status: str  # 在线/离线/故障
    last_update: Optional[datetime] = None
    current_data: Optional[SensorData] = None
    data_history: List[SensorData] = field(default_factory=list)

@dataclass
class MicroZone:
    """微区信息"""
    zone_id: str
    area: float        # 面积(亩)
    salinity: float    # 盐碱度
    ph_value: float    # pH值
    temperature: float # 温度
    humidity: float    # 湿度
    nutrients: Nutrients
    sensors: List[str] = field(default_factory=list)  # 关联的传感器ID

@dataclass
class Plot:
    """地块信息"""
    plot_id: str
    name: str
    area: float
    location: Location
    soil_type: str
    micro_zones: List[MicroZone] = field(default_factory=list)
    sensors: List[Sensor] = field(default_factory=list)
    created_at: datetime = field(default_factory=datetime.now)

@dataclass
class CropRequirements:
    """作物环境需求"""
    temperature_min: float
    temperature_max: float
    ph_min: float
    ph_max: float
    salinity_tolerance: float
    water_requirement: str

@dataclass
class CropEconomics:
    """作物经济数据"""
    cost_per_mu: float      # 成本/亩
    yield_per_mu: float     # 产量/亩
    market_price: float     # 市场价格
    profit_margin: float    # 利润率

@dataclass
class RiskFactors:
    """风险因子"""
    disease_risk: str       # 病害风险
    pest_risk: str          # 虫害风险
    market_risk: str        # 市场风险
    climate_risk: str       # 气候风险

@dataclass
class Crop:
    """作物信息"""
    crop_id: str
    name: str
    variety: str
    category: str
    growth_period: int      # 生长周期(天)
    requirements: CropRequirements
    economics: CropEconomics
    risk_factors: RiskFactors

@dataclass
class RecommendationResult:
    """推荐结果"""
    crop_id: str
    suitability_score: float    # 适应性得分
    profit_score: float         # 收益得分
    risk_score: float           # 风险得分
    overall_score: float        # 综合得分
    zone_assignments: List[str] # 适合的微区
    reasoning: str              # 推荐理由
    data_reliability: float     # 数据可靠性

@dataclass
class Recommendation:
    """完整推荐信息"""
    recommendation_id: str
    plot_id: str
    timestamp: datetime
    sensor_data_used: List[str]  # 使用的传感器数据
    recommendations: List[RecommendationResult]
    market_analysis: Dict[str, any]
```

### 4. 传感器数据管理器 (data/sensor_manager.py)

```python
# 传感器数据管理
import json
from datetime import datetime, timedelta
from typing import List, Dict, Optional
from data.models import Sensor, SensorData
from config import SENSOR_CONFIG

class SensorManager:
    """传感器数据管理器"""
    
    def __init__(self):
        self.sensors: Dict[str, Sensor] = {}
        self.load_sensor_data()
    
    def load_sensor_data(self):
        """加载传感器数据"""
        try:
            with open('assets/data/sensors.json', 'r', encoding='utf-8') as f:
                data = json.load(f)
                for sensor_data in data:
                    sensor = Sensor(**sensor_data)
                    self.sensors[sensor.sensor_id] = sensor
        except FileNotFoundError:
            self.generate_mock_sensors()
    
    def generate_mock_sensors(self):
        """生成模拟传感器数据"""
        import random
        from data.models import Location
        
        mock_sensors = [
            {
                "sensor_id": "S001",
                "sensor_type": "多合一传感器",
                "plot_id": "P001",
                "zone_id": "Z001",
                "location": Location(39.9042, 116.4074),
                "installation_date": datetime(2024, 1, 1),
                "status": "在线"
            },
            {
                "sensor_id": "S002",
                "sensor_type": "土壤传感器",
                "plot_id": "P001",
                "zone_id": "Z002",
                "location": Location(39.9045, 116.4076),
                "installation_date": datetime(2024, 1, 1),
                "status": "在线"
            }
        ]
        
        for sensor_data in mock_sensors:
            sensor = Sensor(**sensor_data)
            # 生成当前数据
            sensor.current_data = self.generate_random_sensor_data()
            sensor.last_update = datetime.now()
            
            # 生成历史数据
            for i in range(24):  # 24小时历史数据
                timestamp = datetime.now() - timedelta(hours=i)
                historical_data = self.generate_random_sensor_data(timestamp)
                sensor.data_history.append(historical_data)
            
            self.sensors[sensor.sensor_id] = sensor
    
    def generate_random_sensor_data(self, timestamp: datetime = None) -> SensorData:
        """生成随机传感器数据"""
        import random
        
        if timestamp is None:
            timestamp = datetime.now()
        
        return SensorData(
            timestamp=timestamp,
            temperature=round(random.uniform(15.0, 30.0), 1),
            humidity=round(random.uniform(40.0, 80.0), 1),
            ph_value=round(random.uniform(6.0, 8.0), 1),
            salinity=round(random.uniform(0.1, 0.8), 2),
            nitrogen=round(random.uniform(20.0, 80.0), 1),
            phosphorus=round(random.uniform(10.0, 50.0), 1),
            potassium=round(random.uniform(50.0, 200.0), 1)
        )
    
    def get_sensor(self, sensor_id: str) -> Optional[Sensor]:
        """获取传感器信息"""
        return self.sensors.get(sensor_id)
    
    def get_sensors_by_plot(self, plot_id: str) -> List[Sensor]:
        """获取地块的所有传感器"""
        return [sensor for sensor in self.sensors.values() 
                if sensor.plot_id == plot_id]
    
    def get_sensors_by_zone(self, zone_id: str) -> List[Sensor]:
        """获取微区的所有传感器"""
        return [sensor for sensor in self.sensors.values() 
                if sensor.zone_id == zone_id]
    
    def update_sensor_data(self, sensor_id: str, data: SensorData) -> bool:
        """更新传感器数据"""
        if sensor_id in self.sensors:
            sensor = self.sensors[sensor_id]
            
            # 更新当前数据
            sensor.current_data = data
            sensor.last_update = datetime.now()
            sensor.status = "在线"
            
            # 添加到历史数据
            sensor.data_history.append(data)
            
            # 保持历史数据量
            max_history = SENSOR_CONFIG.get('data_retention_days', 90) * 24
            if len(sensor.data_history) > max_history:
                sensor.data_history = sensor.data_history[-max_history:]
            
            return True
        return False
    
    def check_sensor_status(self):
        """检查传感器状态"""
        timeout = SENSOR_CONFIG.get('offline_timeout', 1800)
        now = datetime.now()
        
        for sensor in self.sensors.values():
            if sensor.last_update:
                time_diff = (now - sensor.last_update).total_seconds()
                if time_diff > timeout:
                    sensor.status = "离线"
    
    def get_data_quality_score(self, sensor_id: str) -> float:
        """计算传感器数据质量得分"""
        sensor = self.get_sensor(sensor_id)
        if not sensor or not sensor.current_data:
            return 0.0
        
        quality = 100.0
        
        # 检查数据时效性
        if sensor.last_update:
            time_diff = (datetime.now() - sensor.last_update).total_seconds()
            if time_diff > 3600:  # 1小时
                quality -= 20
            elif time_diff > 1800:  # 30分钟
                quality -= 10
        
        # 检查传感器状态
        if sensor.status != "在线":
            quality -= 30
        
        # 检查数据完整性
        data = sensor.current_data
        if not all([data.temperature, data.humidity, data.ph_value, data.salinity]):
            quality -= 20
        
        return max(0, min(100, quality))
    
    def add_sensor(self, sensor: Sensor) -> bool:
        """添加新传感器"""
        if sensor.sensor_id not in self.sensors:
            self.sensors[sensor.sensor_id] = sensor
            return True
        return False
    
    def remove_sensor(self, sensor_id: str) -> bool:
        """移除传感器"""
        if sensor_id in self.sensors:
            del self.sensors[sensor_id]
            return True
        return False
    
    def get_sensor_types(self) -> List[str]:
        """获取支持的传感器类型"""
        return SENSOR_CONFIG.get('supported_types', [])
```

### 5. 传感器数据融合算法 (algorithms/sensor_fusion.py)

```python
# 传感器数据融合算法
import numpy as np
from typing import List, Dict, Optional
from datetime import datetime, timedelta
from data.models import Sensor, SensorData, MicroZone

class SensorDataFusion:
    """传感器数据融合算法"""
    
    def __init__(self):
        self.confidence_weights = {
            "多合一传感器": 1.0,
            "土壤传感器": 0.9,
            "气象传感器": 0.8
        }
    
    def fuse_zone_data(self, zone: MicroZone, sensors: List[Sensor]) -> Dict:
        """融合微区内多个传感器的数据"""
        if not sensors:
            return self._get_zone_baseline_data(zone)
        
        # 过滤有效传感器
        valid_sensors = [s for s in sensors if s.current_data and s.status == "在线"]
        
        if not valid_sensors:
            return self._get_zone_baseline_data(zone)
        
        # 计算加权平均
        fused_data = {}
        total_weight = 0
        
        for sensor in valid_sensors:
            weight = self._calculate_sensor_weight(sensor)
            data = sensor.current_data
            
            for field in ['temperature', 'humidity', 'ph_value', 'salinity', 
                         'nitrogen', 'phosphorus', 'potassium']:
                value = getattr(data, field, 0)
                if field not in fused_data:
                    fused_data[field] = 0
                fused_data[field] += value * weight
            
            total_weight += weight
        
        # 归一化
        if total_weight > 0:
            for field in fused_data:
                fused_data[field] /= total_weight
        
        # 添加融合置信度
        fused_data['fusion_confidence'] = self._calculate_fusion_confidence(valid_sensors)
        fused_data['sensor_count'] = len(valid_sensors)
        fused_data['last_update'] = max([s.last_update for s in valid_sensors])
        
        return fused_data
    
    def _calculate_sensor_weight(self, sensor: Sensor) -> float:
        """计算传感器权重"""
        # 基础权重（基于传感器类型）
        base_weight = self.confidence_weights.get(sensor.sensor_type, 0.5)
        
        # 时效性权重
        time_weight = 1.0
        if sensor.last_update:
            time_diff = (datetime.now() - sensor.last_update).total_seconds()
            if time_diff > 3600:  # 1小时
                time_weight = 0.5
            elif time_diff > 1800:  # 30分钟
                time_weight = 0.8
        
        # 状态权重
        status_weight = 1.0 if sensor.status == "在线" else 0.3
        
        return base_weight * time_weight * status_weight
    
    def _calculate_fusion_confidence(self, sensors: List[Sensor]) -> float:
        """计算融合数据置信度"""
        if not sensors:
            return 0.0
        
        # 传感器数量因子
        count_factor = min(1.0, len(sensors) / 3)  # 3个传感器为满分
        
        # 传感器类型多样性因子
        types = set([s.sensor_type for s in sensors])
        diversity_factor = min(1.0, len(types) / 2)  # 2种类型为满分
        
        # 数据一致性因子
        consistency_factor = self._calculate_data_consistency(sensors)
        
        # 时效性因子
        freshness_factor = self._calculate_data_freshness(sensors)
        
        confidence = (count_factor + diversity_factor + consistency_factor + freshness_factor) / 4
        return round(confidence * 100, 1)
    
    def _calculate_data_consistency(self, sensors: List[Sensor]) -> float:
        """计算数据一致性"""
        if len(sensors) < 2:
            return 1.0
        
        # 计算各参数的标准差
        values = {
            'temperature': [],
            'humidity': [],
            'ph_value': [],
            'salinity': []
        }
        
        for sensor in sensors:
            if sensor.current_data:
                data = sensor.current_data
                values['temperature'].append(data.temperature)
                values['humidity'].append(data.humidity)
                values['ph_value'].append(data.ph_value)
                values['salinity'].append(data.salinity)
        
        consistency_scores = []
        for param, vals in values.items():
            if len(vals) >= 2:
                std = np.std(vals)
                mean = np.mean(vals)
                cv = std / mean if mean > 0 else 0  # 变异系数
                consistency = max(0, 1 - cv)  # 变异系数越小，一致性越高
                consistency_scores.append(consistency)
        
        return np.mean(consistency_scores) if consistency_scores else 1.0
    
    def _calculate_data_freshness(self, sensors: List[Sensor]) -> float:
        """计算数据新鲜度"""
        now = datetime.now()
        freshness_scores = []
        
        for sensor in sensors:
            if sensor.last_update:
                time_diff = (now - sensor.last_update).total_seconds()
                if time_diff <= 300:  # 5分钟内
                    score = 1.0
                elif time_diff <= 1800:  # 30分钟内
                    score = 0.8
                elif time_diff <= 3600:  # 1小时内
                    score = 0.6
                else:
                    score = 0.3
                freshness_scores.append(score)
        
        return np.mean(freshness_scores) if freshness_scores else 0.5
    
    def _get_zone_baseline_data(self, zone: MicroZone) -> Dict:
        """获取微区基础数据（无传感器时）"""
        return {
            'temperature': zone.temperature,
            'humidity': zone.humidity,
            'ph_value': zone.ph_value,
            'salinity': zone.salinity,
            'nitrogen': zone.nutrients.nitrogen,
            'phosphorus': zone.nutrients.phosphorus,
            'potassium': zone.nutrients.potassium,
            'fusion_confidence': 50.0,  # 基础置信度
            'sensor_count': 0,
            'last_update': datetime.now()
        }
    
    def detect_anomalies(self, sensor: Sensor) -> List[str]:
        """检测传感器数据异常"""
        anomalies = []
        
        if not sensor.current_data:
            return ["无当前数据"]
        
        data = sensor.current_data
        
        # 温度异常检测
        if data.temperature < -10 or data.temperature > 50:
            anomalies.append("温度数据异常")
        
        # 湿度异常检测
        if data.humidity < 0 or data.humidity > 100:
            anomalies.append("湿度数据异常")
        
        # pH值异常检测
        if data.ph_value < 3 or data.ph_value > 12:
            anomalies.append("pH值数据异常")
        
        # 盐碱度异常检测
        if data.salinity < 0 or data.salinity > 2:
            anomalies.append("盐碱度数据异常")
        
        # 营养成分异常检测
        if data.nitrogen < 0 or data.nitrogen > 300:
            anomalies.append("氮含量数据异常")
        
        return anomalies
```

### 6. 传感器UI组件 (components/sensors.py)

```python
# 传感器相关UI组件
import streamlit as st
import plotly.graph_objects as go
import plotly.express as px
from datetime import datetime, timedelta
from typing import List, Dict
from data.models import Sensor, SensorData
from data.sensor_manager import SensorManager

class SensorComponents:
    """传感器UI组件"""
    
    def __init__(self):
        self.sensor_manager = SensorManager()
    
    def render_sensor_input_form(self) -> Dict:
        """渲染传感器数据录入表单"""
        st.subheader("📡 传感器数据录入")
        
        col1, col2 = st.columns(2)
        
        with col1:
            sensor_id = st.text_input("传感器ID", placeholder="例：S001")
            sensor_types = self.sensor_manager.get_sensor_types()
            sensor_type = st.selectbox("设备类型", sensor_types)
        
        with col2:
            data_mode = st.selectbox("数据获取方式", ["自动获取", "手动输入"])
            if data_mode == "自动获取":
                if st.button("🔄 同步传感器数据"):
                    return self._sync_sensor_data(sensor_id)
        
        if data_mode == "手动输入":
            return self._render_manual_input_form(sensor_id, sensor_type)
        
        return {}
    
    def _render_manual_input_form(self, sensor_id: str, sensor_type: str) -> Dict:
        """渲染手动输入表单"""
        st.write("手动输入传感器数据：")
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            temperature = st.number_input("温度 (°C)", min_value=-20.0, max_value=50.0, value=20.0, step=0.1)
            humidity = st.number_input("湿度 (%)", min_value=0.0, max_value=100.0, value=60.0, step=0.1)
        
        with col2:
            ph_value = st.number_input("pH值", min_value=3.0, max_value=12.0, value=7.0, step=0.1)
            salinity = st.number_input("盐碱度 (‰)", min_value=0.0, max_value=2.0, value=0.3, step=0.01)
        
        with col3:
            nitrogen = st.number_input("氮含量 (mg/kg)", min_value=0.0, max_value=300.0, value=50.0, step=1.0)
            phosphorus = st.number_input("磷含量 (mg/kg)", min_value=0.0, max_value=100.0, value=30.0, step=1.0)
            potassium = st.number_input("钾含量 (mg/kg)", min_value=0.0, max_value=300.0, value=150.0, step=1.0)
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            if st.button("✅ 验证数据"):
                return self._validate_sensor_data({
                    'temperature': temperature,
                    'humidity': humidity,
                    'ph_value': ph_value,
                    'salinity': salinity,
                    'nitrogen': nitrogen,
                    'phosphorus': phosphorus,
                    'potassium': potassium
                })
        
        with col2:
            if st.button("💾 保存数据"):
                sensor_data = SensorData(
                    timestamp=datetime.now(),
                    temperature=temperature,
                    humidity=humidity,
                    ph_value=ph_value,
                    salinity=salinity,
                    nitrogen=nitrogen,
                    phosphorus=phosphorus,
                    potassium=potassium
                )
                
                if self.sensor_manager.update_sensor_data(sensor_id, sensor_data):
                    st.success("数据保存成功！")
                    return sensor_data.__dict__
                else:
                    st.error("数据保存失败，请检查传感器ID")
        
        with col3:
            if st.button("🔄 应用到推荐"):
                return {
                    'sensor_id': sensor_id,
                    'sensor_type': sensor_type,
                    'temperature': temperature,
                    'humidity': humidity,
                    'ph_value': ph_value,
                    'salinity': salinity,
                    'nitrogen': nitrogen,
                    'phosphorus': phosphorus,
                    'potassium': potassium,
                    'timestamp': datetime.now()
                }
        
        return {}
    
    def _sync_sensor_data(self, sensor_id: str) -> Dict:
        """同步传感器数据"""
        sensor = self.sensor_manager.get_sensor(sensor_id)
        if sensor and sensor.current_data:
            st.success(f"成功同步传感器 {sensor_id} 的数据")
            data = sensor.current_data
            return {
                'sensor_id': sensor_id,
                'temperature': data.temperature,
                'humidity': data.humidity,
                'ph_value': data.ph_value,
                'salinity': data.salinity,
                'nitrogen': data.nitrogen,
                'phosphorus': data.phosphorus,
                'potassium': data.potassium,
                'timestamp': data.timestamp
            }
        else:
            st.error(f"传感器 {sensor_id} 未找到或无数据")
            return {}
    
    def _validate_sensor_data(self, data: Dict) -> Dict:
        """验证传感器数据"""
        warnings = []
        
        # 数据范围检查
        if data['temperature'] < 5 or data['temperature'] > 40:
            warnings.append("⚠️ 温度数据超出正常范围")
        
        if data['ph_value'] < 4 or data['ph_value'] > 10:
            warnings.append("⚠️ pH值超出正常范围")
        
        if data['salinity'] > 1.0:
            warnings.append("⚠️ 盐碱度较高")
        
        if warnings:
            for warning in warnings:
                st.warning(warning)
        else:
            st.success("✅ 数据验证通过")
        
        return data
    
    def render_sensor_status_panel(self, plot_id: str = None):
        """渲染传感器状态面板"""
        st.subheader("📊 传感器状态监控")
        
        if plot_id:
            sensors = self.sensor_manager.get_sensors_by_plot(plot_id)
        else:
            sensors = list(self.sensor_manager.sensors.values())
        
        if not sensors:
            st.info("暂无传感器数据")
            return
        
        # 状态统计
        online_count = sum(1 for s in sensors if s.status == "在线")
        offline_count = len(sensors) - online_count
        
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("传感器总数", len(sensors))
        with col2:
            st.metric("在线设备", online_count, delta=f"+{online_count}")
        with col3:
            st.metric("离线设备", offline_count, delta=f"-{offline_count}" if offline_count > 0 else "0")
        
        # 传感器列表
        for sensor in sensors:
            with st.expander(f"📡 {sensor.sensor_id} - {sensor.sensor_type}"):
                self._render_sensor_detail(sensor)
    
    def _render_sensor_detail(self, sensor: Sensor):
        """渲染传感器详情"""
        col1, col2 = st.columns(2)
        
        with col1:
            st.write(f"**状态**: {sensor.status}")
            st.write(f"**类型**: {sensor.sensor_type}")
            st.write(f"**位置**: {sensor.plot_id} - {sensor.zone_id}")
            if sensor.last_update:
                st.write(f"**最后更新**: {sensor.last_update.strftime('%Y-%m-%d %H:%M:%S')}")
        
        with col2:
            if sensor.current_data:
                data = sensor.current_data
                st.write("**当前数据**:")
                st.write(f"温度: {data.temperature}°C")
                st.write(f"湿度: {data.humidity}%")
                st.write(f"pH值: {data.ph_value}")
                st.write(f"盐碱度: {data.salinity}‰")
        
        # 数据质量评分
        quality_score = self.sensor_manager.get_data_quality_score(sensor.sensor_id)
        st.progress(quality_score / 100)
        st.write(f"数据质量评分: {quality_score}/100")
    
    def render_sensor_history_chart(self, sensor_id: str, hours: int = 24):
        """渲染传感器历史数据图表"""
        sensor = self.sensor_manager.get_sensor(sensor_id)
        if not sensor or not sensor.data_history:
            st.info("暂无历史数据")
            return
        
        # 准备数据
        recent_data = [d for d in sensor.data_history 
                      if d.timestamp >= datetime.now() - timedelta(hours=hours)]
        
        if not recent_data:
            st.info(f"最近{hours}小时无数据")
            return
        
        timestamps = [d.timestamp for d in recent_data]
        temperatures = [d.temperature for d in recent_data]
        humidities = [d.humidity for d in recent_data]
        ph_values = [d.ph_value for d in recent_data]
        
        # 创建图表
        fig = go.Figure()
        
        fig.add_trace(go.Scatter(
            x=timestamps, y=temperatures,
            mode='lines+markers',
            name='温度 (°C)',
            line=dict(color='red')
        ))
        
        fig.add_trace(go.Scatter(
            x=timestamps, y=humidities,
            mode='lines+markers',
            name='湿度 (%)',
            line=dict(color='blue'),
            yaxis='y2'
        ))
        
        fig.add_trace(go.Scatter(
            x=timestamps, y=ph_values,
            mode='lines+markers',
            name='pH值',
            line=dict(color='green'),
            yaxis='y3'
        ))
        
        fig.update_layout(
            title=f'传感器 {sensor_id} 历史数据趋势',
            xaxis=dict(title='时间'),
            yaxis=dict(title='温度 (°C)', side='left'),
            yaxis2=dict(title='湿度 (%)', side='right', overlaying='y'),
            yaxis3=dict(title='pH值', side='right', overlaying='y', position=0.85),
            height=400
        )
        
        st.plotly_chart(fig, use_container_width=True)
```

## 部署配置

### requirements.txt
```
streamlit>=1.28.0
plotly>=5.15.0
pandas>=2.0.0
numpy>=1.24.0
folium>=0.14.0
streamlit-folium>=0.13.0
Pillow>=10.0.0
requests>=2.31.0
scikit-learn>=1.3.0
```

### 启动脚本 (run.bat)
```batch
@echo off
echo 启动智播农链系统...
streamlit run app.py --server.port 8501 --server.address 0.0.0.0
pause
```

这个技术架构设计为"智播农链"项目提供了完整的代码结构和组件设计方案，特别加强了传感器数据集成功能，确保项目开发的规范性和可维护性。 