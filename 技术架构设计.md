# æ™ºæ’­å†œé“¾â€”â€”æŠ€æœ¯æ¶æ„è®¾è®¡æ–‡æ¡£

## é¡¹ç›®ç›®å½•ç»“æ„

```
æ™ºæ’­å†œé“¾/
â”œâ”€â”€ app.py                      # Streamlitä¸»åº”ç”¨å…¥å£
â”œâ”€â”€ requirements.txt            # é¡¹ç›®ä¾èµ–åŒ…
â”œâ”€â”€ config.py                   # é…ç½®æ–‡ä»¶
â”œâ”€â”€ README.md                   # é¡¹ç›®è¯´æ˜æ–‡æ¡£
â”œâ”€â”€ 
â”œâ”€â”€ pages/                      # é¡µé¢æ¨¡å—
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ dashboard.py           # é¦–é¡µ/ä»ªè¡¨æ¿
â”‚   â”œâ”€â”€ plot_management.py     # åœ°å—ç®¡ç†
â”‚   â”œâ”€â”€ crop_recommendation.py # ä½œç‰©æ¨è
â”‚   â”œâ”€â”€ crop_detail.py         # ä½œç‰©è¯¦æƒ…åˆ†æ
â”‚   â””â”€â”€ data_analysis.py       # æ•°æ®åˆ†æ
â”‚
â”œâ”€â”€ components/                 # UIç»„ä»¶åº“
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ layout.py              # å¸ƒå±€ç»„ä»¶
â”‚   â”œâ”€â”€ navigation.py          # å¯¼èˆªç»„ä»¶
â”‚   â”œâ”€â”€ cards.py               # å¡ç‰‡ç»„ä»¶
â”‚   â”œâ”€â”€ charts.py              # å›¾è¡¨ç»„ä»¶
â”‚   â”œâ”€â”€ forms.py               # è¡¨å•ç»„ä»¶
â”‚   â”œâ”€â”€ maps.py                # åœ°å›¾ç»„ä»¶
â”‚   â”œâ”€â”€ sensors.py             # ä¼ æ„Ÿå™¨ç»„ä»¶
â”‚   â””â”€â”€ widgets.py             # é€šç”¨å°éƒ¨ä»¶
â”‚
â”œâ”€â”€ data/                       # æ•°æ®å±‚
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ mock_data.py           # æ¨¡æ‹Ÿæ•°æ®ç”Ÿæˆ
â”‚   â”œâ”€â”€ data_manager.py        # æ•°æ®ç®¡ç†å™¨
â”‚   â”œâ”€â”€ validators.py          # æ•°æ®éªŒè¯
â”‚   â”œâ”€â”€ models.py              # æ•°æ®æ¨¡å‹
â”‚   â””â”€â”€ sensor_manager.py      # ä¼ æ„Ÿå™¨æ•°æ®ç®¡ç†
â”‚
â”œâ”€â”€ algorithms/                 # ç®—æ³•æ¨¡å—
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ recommendation.py      # æ¨èç®—æ³•
â”‚   â”œâ”€â”€ evaluation.py          # è¯„ä¼°ç®—æ³•
â”‚   â”œâ”€â”€ prediction.py          # é¢„æµ‹ç®—æ³•
â”‚   â”œâ”€â”€ analytics.py           # åˆ†æç®—æ³•
â”‚   â””â”€â”€ sensor_fusion.py       # ä¼ æ„Ÿå™¨æ•°æ®èåˆ
â”‚
â”œâ”€â”€ utils/                      # å·¥å…·å‡½æ•°
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ helpers.py             # è¾…åŠ©å‡½æ•°
â”‚   â”œâ”€â”€ constants.py           # å¸¸é‡å®šä¹‰
â”‚   â””â”€â”€ decorators.py          # è£…é¥°å™¨
â”‚
â”œâ”€â”€ assets/                     # é™æ€èµ„æº
â”‚   â”œâ”€â”€ css/                   # æ ·å¼æ–‡ä»¶
â”‚   â”‚   â”œâ”€â”€ main.css
â”‚   â”‚   â””â”€â”€ components.css
â”‚   â”œâ”€â”€ images/                # å›¾ç‰‡èµ„æº
â”‚   â”‚   â”œâ”€â”€ logo.png
â”‚   â”‚   â””â”€â”€ icons/
â”‚   â””â”€â”€ data/                  # é™æ€æ•°æ®æ–‡ä»¶
â”‚       â”œâ”€â”€ crops.json
â”‚       â”œâ”€â”€ regions.json
â”‚       â”œâ”€â”€ weather.json
â”‚       â””â”€â”€ sensors.json
â”‚
â””â”€â”€ tests/                      # æµ‹è¯•æ–‡ä»¶
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ test_algorithms.py
    â”œâ”€â”€ test_data.py
    â”œâ”€â”€ test_components.py
    â””â”€â”€ test_sensors.py
```

## æ ¸å¿ƒç»„ä»¶è®¾è®¡

### 1. ä¸»åº”ç”¨å…¥å£ (app.py)

```python
# åº”ç”¨é…ç½®å’Œè·¯ç”±ç®¡ç†
import streamlit as st
from pages import (
    dashboard, plot_management, crop_recommendation,
    crop_detail, data_analysis
)
from components.navigation import setup_navigation
from components.layout import apply_custom_css
from utils.constants import PAGE_CONFIG

def main():
    # é¡µé¢é…ç½®
    st.set_page_config(**PAGE_CONFIG)
    
    # åº”ç”¨è‡ªå®šä¹‰CSS
    apply_custom_css()
    
    # è®¾ç½®å¯¼èˆª
    page = setup_navigation()
    
    # è·¯ç”±åˆ°å¯¹åº”é¡µé¢
    if page == "é¦–é¡µ":
        dashboard.show()
    elif page == "åœ°å—ç®¡ç†":
        plot_management.show()
    elif page == "ä½œç‰©æ¨è":
        crop_recommendation.show()
    elif page == "ä½œç‰©è¯¦æƒ…":
        crop_detail.show()
    elif page == "æ•°æ®åˆ†æ":
        data_analysis.show()

if __name__ == "__main__":
    main()
```

### 2. é…ç½®æ–‡ä»¶ (config.py)

```python
# ç³»ç»Ÿé…ç½®å‚æ•°
import os

# åº”ç”¨é…ç½®
APP_CONFIG = {
    "title": "æ™ºæ’­å†œé“¾",
    "subtitle": "AIé©±åŠ¨å†œä¸šå…¨æµç¨‹æ•°æ™ºå‡çº§",
    "version": "1.0.0",
    "theme": "light",
    "primary_color": "#90EE90"
}

# é¡µé¢é…ç½®
PAGE_CONFIG = {
    "page_title": "æ™ºæ’­å†œé“¾ - ä½œç‰©æ¨èç³»ç»Ÿ",
    "page_icon": "ğŸŒ±",
    "layout": "wide",
    "initial_sidebar_state": "expanded"
}

# æ¨èç®—æ³•æƒé‡é…ç½®
ALGORITHM_WEIGHTS = {
    "environmental": 0.30,  # ç¯å¢ƒé€‚åº”æ€§
    "profit": 0.25,         # ç»æµæ•ˆç›Š
    "risk": 0.20,           # é£é™©è¯„ä¼°
    "technical": 0.15,      # æŠ€æœ¯éš¾åº¦
    "market": 0.10          # å¸‚åœºå‰æ™¯
}

# æ•°æ®æºé…ç½®
DATA_SOURCES = {
    "weather_api": "http://api.weather.com",
    "soil_database": "sqlite:///data/soil.db",
    "market_api": "http://api.market.com",
    "expert_knowledge": "data/expert_rules.json"
}

# ä¼ æ„Ÿå™¨é…ç½®
SENSOR_CONFIG = {
    "supported_types": ["åœŸå£¤ä¼ æ„Ÿå™¨", "æ°”è±¡ä¼ æ„Ÿå™¨", "å¤šåˆä¸€ä¼ æ„Ÿå™¨"],
    "data_update_interval": 300,  # 5åˆ†é’Ÿ
    "data_retention_days": 90,
    "quality_threshold": 0.8,
    "offline_timeout": 1800  # 30åˆ†é’Ÿ
}

# æ ·å¼é…ç½®
COLORS = {
    "primary": "#90EE90",     # æµ…ç»¿è‰²ä¸»è‰²
    "secondary": "#98FB98",   # æ¬¡è¦ç»¿è‰²
    "accent": "#00CED1",      # å¼ºè°ƒè‰²
    "background": "#F5F5F5",  # èƒŒæ™¯è‰²
    "text": "#333333",        # æ–‡å­—è‰²
    "border": "#E0E0E0"       # è¾¹æ¡†è‰²
}
```

### 3. æ•°æ®æ¨¡å‹ (data/models.py)

```python
# æ•°æ®ç»“æ„å®šä¹‰
from dataclasses import dataclass, field
from typing import List, Dict, Optional
from datetime import datetime

@dataclass
class Location:
    """åœ°ç†ä½ç½®ä¿¡æ¯"""
    latitude: float
    longitude: float
    address: str = ""

@dataclass
class Nutrients:
    """åœŸå£¤è¥å…»æˆåˆ†"""
    nitrogen: float    # æ°®å«é‡
    phosphorus: float  # ç£·å«é‡
    potassium: float   # é’¾å«é‡

@dataclass
class SensorData:
    """ä¼ æ„Ÿå™¨æ•°æ®ç‚¹"""
    timestamp: datetime
    temperature: float
    humidity: float
    ph_value: float
    salinity: float
    nitrogen: float = 0.0
    phosphorus: float = 0.0
    potassium: float = 0.0

@dataclass
class Sensor:
    """ä¼ æ„Ÿå™¨è®¾å¤‡ä¿¡æ¯"""
    sensor_id: str
    sensor_type: str
    plot_id: str
    zone_id: str
    location: Location
    installation_date: datetime
    status: str  # åœ¨çº¿/ç¦»çº¿/æ•…éšœ
    last_update: Optional[datetime] = None
    current_data: Optional[SensorData] = None
    data_history: List[SensorData] = field(default_factory=list)

@dataclass
class MicroZone:
    """å¾®åŒºä¿¡æ¯"""
    zone_id: str
    area: float        # é¢ç§¯(äº©)
    salinity: float    # ç›ç¢±åº¦
    ph_value: float    # pHå€¼
    temperature: float # æ¸©åº¦
    humidity: float    # æ¹¿åº¦
    nutrients: Nutrients
    sensors: List[str] = field(default_factory=list)  # å…³è”çš„ä¼ æ„Ÿå™¨ID

@dataclass
class Plot:
    """åœ°å—ä¿¡æ¯"""
    plot_id: str
    name: str
    area: float
    location: Location
    soil_type: str
    micro_zones: List[MicroZone] = field(default_factory=list)
    sensors: List[Sensor] = field(default_factory=list)
    created_at: datetime = field(default_factory=datetime.now)

@dataclass
class CropRequirements:
    """ä½œç‰©ç¯å¢ƒéœ€æ±‚"""
    temperature_min: float
    temperature_max: float
    ph_min: float
    ph_max: float
    salinity_tolerance: float
    water_requirement: str

@dataclass
class CropEconomics:
    """ä½œç‰©ç»æµæ•°æ®"""
    cost_per_mu: float      # æˆæœ¬/äº©
    yield_per_mu: float     # äº§é‡/äº©
    market_price: float     # å¸‚åœºä»·æ ¼
    profit_margin: float    # åˆ©æ¶¦ç‡

@dataclass
class RiskFactors:
    """é£é™©å› å­"""
    disease_risk: str       # ç—…å®³é£é™©
    pest_risk: str          # è™«å®³é£é™©
    market_risk: str        # å¸‚åœºé£é™©
    climate_risk: str       # æ°”å€™é£é™©

@dataclass
class Crop:
    """ä½œç‰©ä¿¡æ¯"""
    crop_id: str
    name: str
    variety: str
    category: str
    growth_period: int      # ç”Ÿé•¿å‘¨æœŸ(å¤©)
    requirements: CropRequirements
    economics: CropEconomics
    risk_factors: RiskFactors

@dataclass
class RecommendationResult:
    """æ¨èç»“æœ"""
    crop_id: str
    suitability_score: float    # é€‚åº”æ€§å¾—åˆ†
    profit_score: float         # æ”¶ç›Šå¾—åˆ†
    risk_score: float           # é£é™©å¾—åˆ†
    overall_score: float        # ç»¼åˆå¾—åˆ†
    zone_assignments: List[str] # é€‚åˆçš„å¾®åŒº
    reasoning: str              # æ¨èç†ç”±
    data_reliability: float     # æ•°æ®å¯é æ€§

@dataclass
class Recommendation:
    """å®Œæ•´æ¨èä¿¡æ¯"""
    recommendation_id: str
    plot_id: str
    timestamp: datetime
    sensor_data_used: List[str]  # ä½¿ç”¨çš„ä¼ æ„Ÿå™¨æ•°æ®
    recommendations: List[RecommendationResult]
    market_analysis: Dict[str, any]
```

### 4. ä¼ æ„Ÿå™¨æ•°æ®ç®¡ç†å™¨ (data/sensor_manager.py)

```python
# ä¼ æ„Ÿå™¨æ•°æ®ç®¡ç†
import json
from datetime import datetime, timedelta
from typing import List, Dict, Optional
from data.models import Sensor, SensorData
from config import SENSOR_CONFIG

class SensorManager:
    """ä¼ æ„Ÿå™¨æ•°æ®ç®¡ç†å™¨"""
    
    def __init__(self):
        self.sensors: Dict[str, Sensor] = {}
        self.load_sensor_data()
    
    def load_sensor_data(self):
        """åŠ è½½ä¼ æ„Ÿå™¨æ•°æ®"""
        try:
            with open('assets/data/sensors.json', 'r', encoding='utf-8') as f:
                data = json.load(f)
                for sensor_data in data:
                    sensor = Sensor(**sensor_data)
                    self.sensors[sensor.sensor_id] = sensor
        except FileNotFoundError:
            self.generate_mock_sensors()
    
    def generate_mock_sensors(self):
        """ç”Ÿæˆæ¨¡æ‹Ÿä¼ æ„Ÿå™¨æ•°æ®"""
        import random
        from data.models import Location
        
        mock_sensors = [
            {
                "sensor_id": "S001",
                "sensor_type": "å¤šåˆä¸€ä¼ æ„Ÿå™¨",
                "plot_id": "P001",
                "zone_id": "Z001",
                "location": Location(39.9042, 116.4074),
                "installation_date": datetime(2024, 1, 1),
                "status": "åœ¨çº¿"
            },
            {
                "sensor_id": "S002",
                "sensor_type": "åœŸå£¤ä¼ æ„Ÿå™¨",
                "plot_id": "P001",
                "zone_id": "Z002",
                "location": Location(39.9045, 116.4076),
                "installation_date": datetime(2024, 1, 1),
                "status": "åœ¨çº¿"
            }
        ]
        
        for sensor_data in mock_sensors:
            sensor = Sensor(**sensor_data)
            # ç”Ÿæˆå½“å‰æ•°æ®
            sensor.current_data = self.generate_random_sensor_data()
            sensor.last_update = datetime.now()
            
            # ç”Ÿæˆå†å²æ•°æ®
            for i in range(24):  # 24å°æ—¶å†å²æ•°æ®
                timestamp = datetime.now() - timedelta(hours=i)
                historical_data = self.generate_random_sensor_data(timestamp)
                sensor.data_history.append(historical_data)
            
            self.sensors[sensor.sensor_id] = sensor
    
    def generate_random_sensor_data(self, timestamp: datetime = None) -> SensorData:
        """ç”Ÿæˆéšæœºä¼ æ„Ÿå™¨æ•°æ®"""
        import random
        
        if timestamp is None:
            timestamp = datetime.now()
        
        return SensorData(
            timestamp=timestamp,
            temperature=round(random.uniform(15.0, 30.0), 1),
            humidity=round(random.uniform(40.0, 80.0), 1),
            ph_value=round(random.uniform(6.0, 8.0), 1),
            salinity=round(random.uniform(0.1, 0.8), 2),
            nitrogen=round(random.uniform(20.0, 80.0), 1),
            phosphorus=round(random.uniform(10.0, 50.0), 1),
            potassium=round(random.uniform(50.0, 200.0), 1)
        )
    
    def get_sensor(self, sensor_id: str) -> Optional[Sensor]:
        """è·å–ä¼ æ„Ÿå™¨ä¿¡æ¯"""
        return self.sensors.get(sensor_id)
    
    def get_sensors_by_plot(self, plot_id: str) -> List[Sensor]:
        """è·å–åœ°å—çš„æ‰€æœ‰ä¼ æ„Ÿå™¨"""
        return [sensor for sensor in self.sensors.values() 
                if sensor.plot_id == plot_id]
    
    def get_sensors_by_zone(self, zone_id: str) -> List[Sensor]:
        """è·å–å¾®åŒºçš„æ‰€æœ‰ä¼ æ„Ÿå™¨"""
        return [sensor for sensor in self.sensors.values() 
                if sensor.zone_id == zone_id]
    
    def update_sensor_data(self, sensor_id: str, data: SensorData) -> bool:
        """æ›´æ–°ä¼ æ„Ÿå™¨æ•°æ®"""
        if sensor_id in self.sensors:
            sensor = self.sensors[sensor_id]
            
            # æ›´æ–°å½“å‰æ•°æ®
            sensor.current_data = data
            sensor.last_update = datetime.now()
            sensor.status = "åœ¨çº¿"
            
            # æ·»åŠ åˆ°å†å²æ•°æ®
            sensor.data_history.append(data)
            
            # ä¿æŒå†å²æ•°æ®é‡
            max_history = SENSOR_CONFIG.get('data_retention_days', 90) * 24
            if len(sensor.data_history) > max_history:
                sensor.data_history = sensor.data_history[-max_history:]
            
            return True
        return False
    
    def check_sensor_status(self):
        """æ£€æŸ¥ä¼ æ„Ÿå™¨çŠ¶æ€"""
        timeout = SENSOR_CONFIG.get('offline_timeout', 1800)
        now = datetime.now()
        
        for sensor in self.sensors.values():
            if sensor.last_update:
                time_diff = (now - sensor.last_update).total_seconds()
                if time_diff > timeout:
                    sensor.status = "ç¦»çº¿"
    
    def get_data_quality_score(self, sensor_id: str) -> float:
        """è®¡ç®—ä¼ æ„Ÿå™¨æ•°æ®è´¨é‡å¾—åˆ†"""
        sensor = self.get_sensor(sensor_id)
        if not sensor or not sensor.current_data:
            return 0.0
        
        quality = 100.0
        
        # æ£€æŸ¥æ•°æ®æ—¶æ•ˆæ€§
        if sensor.last_update:
            time_diff = (datetime.now() - sensor.last_update).total_seconds()
            if time_diff > 3600:  # 1å°æ—¶
                quality -= 20
            elif time_diff > 1800:  # 30åˆ†é’Ÿ
                quality -= 10
        
        # æ£€æŸ¥ä¼ æ„Ÿå™¨çŠ¶æ€
        if sensor.status != "åœ¨çº¿":
            quality -= 30
        
        # æ£€æŸ¥æ•°æ®å®Œæ•´æ€§
        data = sensor.current_data
        if not all([data.temperature, data.humidity, data.ph_value, data.salinity]):
            quality -= 20
        
        return max(0, min(100, quality))
    
    def add_sensor(self, sensor: Sensor) -> bool:
        """æ·»åŠ æ–°ä¼ æ„Ÿå™¨"""
        if sensor.sensor_id not in self.sensors:
            self.sensors[sensor.sensor_id] = sensor
            return True
        return False
    
    def remove_sensor(self, sensor_id: str) -> bool:
        """ç§»é™¤ä¼ æ„Ÿå™¨"""
        if sensor_id in self.sensors:
            del self.sensors[sensor_id]
            return True
        return False
    
    def get_sensor_types(self) -> List[str]:
        """è·å–æ”¯æŒçš„ä¼ æ„Ÿå™¨ç±»å‹"""
        return SENSOR_CONFIG.get('supported_types', [])
```

### 5. ä¼ æ„Ÿå™¨æ•°æ®èåˆç®—æ³• (algorithms/sensor_fusion.py)

```python
# ä¼ æ„Ÿå™¨æ•°æ®èåˆç®—æ³•
import numpy as np
from typing import List, Dict, Optional
from datetime import datetime, timedelta
from data.models import Sensor, SensorData, MicroZone

class SensorDataFusion:
    """ä¼ æ„Ÿå™¨æ•°æ®èåˆç®—æ³•"""
    
    def __init__(self):
        self.confidence_weights = {
            "å¤šåˆä¸€ä¼ æ„Ÿå™¨": 1.0,
            "åœŸå£¤ä¼ æ„Ÿå™¨": 0.9,
            "æ°”è±¡ä¼ æ„Ÿå™¨": 0.8
        }
    
    def fuse_zone_data(self, zone: MicroZone, sensors: List[Sensor]) -> Dict:
        """èåˆå¾®åŒºå†…å¤šä¸ªä¼ æ„Ÿå™¨çš„æ•°æ®"""
        if not sensors:
            return self._get_zone_baseline_data(zone)
        
        # è¿‡æ»¤æœ‰æ•ˆä¼ æ„Ÿå™¨
        valid_sensors = [s for s in sensors if s.current_data and s.status == "åœ¨çº¿"]
        
        if not valid_sensors:
            return self._get_zone_baseline_data(zone)
        
        # è®¡ç®—åŠ æƒå¹³å‡
        fused_data = {}
        total_weight = 0
        
        for sensor in valid_sensors:
            weight = self._calculate_sensor_weight(sensor)
            data = sensor.current_data
            
            for field in ['temperature', 'humidity', 'ph_value', 'salinity', 
                         'nitrogen', 'phosphorus', 'potassium']:
                value = getattr(data, field, 0)
                if field not in fused_data:
                    fused_data[field] = 0
                fused_data[field] += value * weight
            
            total_weight += weight
        
        # å½’ä¸€åŒ–
        if total_weight > 0:
            for field in fused_data:
                fused_data[field] /= total_weight
        
        # æ·»åŠ èåˆç½®ä¿¡åº¦
        fused_data['fusion_confidence'] = self._calculate_fusion_confidence(valid_sensors)
        fused_data['sensor_count'] = len(valid_sensors)
        fused_data['last_update'] = max([s.last_update for s in valid_sensors])
        
        return fused_data
    
    def _calculate_sensor_weight(self, sensor: Sensor) -> float:
        """è®¡ç®—ä¼ æ„Ÿå™¨æƒé‡"""
        # åŸºç¡€æƒé‡ï¼ˆåŸºäºä¼ æ„Ÿå™¨ç±»å‹ï¼‰
        base_weight = self.confidence_weights.get(sensor.sensor_type, 0.5)
        
        # æ—¶æ•ˆæ€§æƒé‡
        time_weight = 1.0
        if sensor.last_update:
            time_diff = (datetime.now() - sensor.last_update).total_seconds()
            if time_diff > 3600:  # 1å°æ—¶
                time_weight = 0.5
            elif time_diff > 1800:  # 30åˆ†é’Ÿ
                time_weight = 0.8
        
        # çŠ¶æ€æƒé‡
        status_weight = 1.0 if sensor.status == "åœ¨çº¿" else 0.3
        
        return base_weight * time_weight * status_weight
    
    def _calculate_fusion_confidence(self, sensors: List[Sensor]) -> float:
        """è®¡ç®—èåˆæ•°æ®ç½®ä¿¡åº¦"""
        if not sensors:
            return 0.0
        
        # ä¼ æ„Ÿå™¨æ•°é‡å› å­
        count_factor = min(1.0, len(sensors) / 3)  # 3ä¸ªä¼ æ„Ÿå™¨ä¸ºæ»¡åˆ†
        
        # ä¼ æ„Ÿå™¨ç±»å‹å¤šæ ·æ€§å› å­
        types = set([s.sensor_type for s in sensors])
        diversity_factor = min(1.0, len(types) / 2)  # 2ç§ç±»å‹ä¸ºæ»¡åˆ†
        
        # æ•°æ®ä¸€è‡´æ€§å› å­
        consistency_factor = self._calculate_data_consistency(sensors)
        
        # æ—¶æ•ˆæ€§å› å­
        freshness_factor = self._calculate_data_freshness(sensors)
        
        confidence = (count_factor + diversity_factor + consistency_factor + freshness_factor) / 4
        return round(confidence * 100, 1)
    
    def _calculate_data_consistency(self, sensors: List[Sensor]) -> float:
        """è®¡ç®—æ•°æ®ä¸€è‡´æ€§"""
        if len(sensors) < 2:
            return 1.0
        
        # è®¡ç®—å„å‚æ•°çš„æ ‡å‡†å·®
        values = {
            'temperature': [],
            'humidity': [],
            'ph_value': [],
            'salinity': []
        }
        
        for sensor in sensors:
            if sensor.current_data:
                data = sensor.current_data
                values['temperature'].append(data.temperature)
                values['humidity'].append(data.humidity)
                values['ph_value'].append(data.ph_value)
                values['salinity'].append(data.salinity)
        
        consistency_scores = []
        for param, vals in values.items():
            if len(vals) >= 2:
                std = np.std(vals)
                mean = np.mean(vals)
                cv = std / mean if mean > 0 else 0  # å˜å¼‚ç³»æ•°
                consistency = max(0, 1 - cv)  # å˜å¼‚ç³»æ•°è¶Šå°ï¼Œä¸€è‡´æ€§è¶Šé«˜
                consistency_scores.append(consistency)
        
        return np.mean(consistency_scores) if consistency_scores else 1.0
    
    def _calculate_data_freshness(self, sensors: List[Sensor]) -> float:
        """è®¡ç®—æ•°æ®æ–°é²œåº¦"""
        now = datetime.now()
        freshness_scores = []
        
        for sensor in sensors:
            if sensor.last_update:
                time_diff = (now - sensor.last_update).total_seconds()
                if time_diff <= 300:  # 5åˆ†é’Ÿå†…
                    score = 1.0
                elif time_diff <= 1800:  # 30åˆ†é’Ÿå†…
                    score = 0.8
                elif time_diff <= 3600:  # 1å°æ—¶å†…
                    score = 0.6
                else:
                    score = 0.3
                freshness_scores.append(score)
        
        return np.mean(freshness_scores) if freshness_scores else 0.5
    
    def _get_zone_baseline_data(self, zone: MicroZone) -> Dict:
        """è·å–å¾®åŒºåŸºç¡€æ•°æ®ï¼ˆæ— ä¼ æ„Ÿå™¨æ—¶ï¼‰"""
        return {
            'temperature': zone.temperature,
            'humidity': zone.humidity,
            'ph_value': zone.ph_value,
            'salinity': zone.salinity,
            'nitrogen': zone.nutrients.nitrogen,
            'phosphorus': zone.nutrients.phosphorus,
            'potassium': zone.nutrients.potassium,
            'fusion_confidence': 50.0,  # åŸºç¡€ç½®ä¿¡åº¦
            'sensor_count': 0,
            'last_update': datetime.now()
        }
    
    def detect_anomalies(self, sensor: Sensor) -> List[str]:
        """æ£€æµ‹ä¼ æ„Ÿå™¨æ•°æ®å¼‚å¸¸"""
        anomalies = []
        
        if not sensor.current_data:
            return ["æ— å½“å‰æ•°æ®"]
        
        data = sensor.current_data
        
        # æ¸©åº¦å¼‚å¸¸æ£€æµ‹
        if data.temperature < -10 or data.temperature > 50:
            anomalies.append("æ¸©åº¦æ•°æ®å¼‚å¸¸")
        
        # æ¹¿åº¦å¼‚å¸¸æ£€æµ‹
        if data.humidity < 0 or data.humidity > 100:
            anomalies.append("æ¹¿åº¦æ•°æ®å¼‚å¸¸")
        
        # pHå€¼å¼‚å¸¸æ£€æµ‹
        if data.ph_value < 3 or data.ph_value > 12:
            anomalies.append("pHå€¼æ•°æ®å¼‚å¸¸")
        
        # ç›ç¢±åº¦å¼‚å¸¸æ£€æµ‹
        if data.salinity < 0 or data.salinity > 2:
            anomalies.append("ç›ç¢±åº¦æ•°æ®å¼‚å¸¸")
        
        # è¥å…»æˆåˆ†å¼‚å¸¸æ£€æµ‹
        if data.nitrogen < 0 or data.nitrogen > 300:
            anomalies.append("æ°®å«é‡æ•°æ®å¼‚å¸¸")
        
        return anomalies
```

### 6. ä¼ æ„Ÿå™¨UIç»„ä»¶ (components/sensors.py)

```python
# ä¼ æ„Ÿå™¨ç›¸å…³UIç»„ä»¶
import streamlit as st
import plotly.graph_objects as go
import plotly.express as px
from datetime import datetime, timedelta
from typing import List, Dict
from data.models import Sensor, SensorData
from data.sensor_manager import SensorManager

class SensorComponents:
    """ä¼ æ„Ÿå™¨UIç»„ä»¶"""
    
    def __init__(self):
        self.sensor_manager = SensorManager()
    
    def render_sensor_input_form(self) -> Dict:
        """æ¸²æŸ“ä¼ æ„Ÿå™¨æ•°æ®å½•å…¥è¡¨å•"""
        st.subheader("ğŸ“¡ ä¼ æ„Ÿå™¨æ•°æ®å½•å…¥")
        
        col1, col2 = st.columns(2)
        
        with col1:
            sensor_id = st.text_input("ä¼ æ„Ÿå™¨ID", placeholder="ä¾‹ï¼šS001")
            sensor_types = self.sensor_manager.get_sensor_types()
            sensor_type = st.selectbox("è®¾å¤‡ç±»å‹", sensor_types)
        
        with col2:
            data_mode = st.selectbox("æ•°æ®è·å–æ–¹å¼", ["è‡ªåŠ¨è·å–", "æ‰‹åŠ¨è¾“å…¥"])
            if data_mode == "è‡ªåŠ¨è·å–":
                if st.button("ğŸ”„ åŒæ­¥ä¼ æ„Ÿå™¨æ•°æ®"):
                    return self._sync_sensor_data(sensor_id)
        
        if data_mode == "æ‰‹åŠ¨è¾“å…¥":
            return self._render_manual_input_form(sensor_id, sensor_type)
        
        return {}
    
    def _render_manual_input_form(self, sensor_id: str, sensor_type: str) -> Dict:
        """æ¸²æŸ“æ‰‹åŠ¨è¾“å…¥è¡¨å•"""
        st.write("æ‰‹åŠ¨è¾“å…¥ä¼ æ„Ÿå™¨æ•°æ®ï¼š")
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            temperature = st.number_input("æ¸©åº¦ (Â°C)", min_value=-20.0, max_value=50.0, value=20.0, step=0.1)
            humidity = st.number_input("æ¹¿åº¦ (%)", min_value=0.0, max_value=100.0, value=60.0, step=0.1)
        
        with col2:
            ph_value = st.number_input("pHå€¼", min_value=3.0, max_value=12.0, value=7.0, step=0.1)
            salinity = st.number_input("ç›ç¢±åº¦ (â€°)", min_value=0.0, max_value=2.0, value=0.3, step=0.01)
        
        with col3:
            nitrogen = st.number_input("æ°®å«é‡ (mg/kg)", min_value=0.0, max_value=300.0, value=50.0, step=1.0)
            phosphorus = st.number_input("ç£·å«é‡ (mg/kg)", min_value=0.0, max_value=100.0, value=30.0, step=1.0)
            potassium = st.number_input("é’¾å«é‡ (mg/kg)", min_value=0.0, max_value=300.0, value=150.0, step=1.0)
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            if st.button("âœ… éªŒè¯æ•°æ®"):
                return self._validate_sensor_data({
                    'temperature': temperature,
                    'humidity': humidity,
                    'ph_value': ph_value,
                    'salinity': salinity,
                    'nitrogen': nitrogen,
                    'phosphorus': phosphorus,
                    'potassium': potassium
                })
        
        with col2:
            if st.button("ğŸ’¾ ä¿å­˜æ•°æ®"):
                sensor_data = SensorData(
                    timestamp=datetime.now(),
                    temperature=temperature,
                    humidity=humidity,
                    ph_value=ph_value,
                    salinity=salinity,
                    nitrogen=nitrogen,
                    phosphorus=phosphorus,
                    potassium=potassium
                )
                
                if self.sensor_manager.update_sensor_data(sensor_id, sensor_data):
                    st.success("æ•°æ®ä¿å­˜æˆåŠŸï¼")
                    return sensor_data.__dict__
                else:
                    st.error("æ•°æ®ä¿å­˜å¤±è´¥ï¼Œè¯·æ£€æŸ¥ä¼ æ„Ÿå™¨ID")
        
        with col3:
            if st.button("ğŸ”„ åº”ç”¨åˆ°æ¨è"):
                return {
                    'sensor_id': sensor_id,
                    'sensor_type': sensor_type,
                    'temperature': temperature,
                    'humidity': humidity,
                    'ph_value': ph_value,
                    'salinity': salinity,
                    'nitrogen': nitrogen,
                    'phosphorus': phosphorus,
                    'potassium': potassium,
                    'timestamp': datetime.now()
                }
        
        return {}
    
    def _sync_sensor_data(self, sensor_id: str) -> Dict:
        """åŒæ­¥ä¼ æ„Ÿå™¨æ•°æ®"""
        sensor = self.sensor_manager.get_sensor(sensor_id)
        if sensor and sensor.current_data:
            st.success(f"æˆåŠŸåŒæ­¥ä¼ æ„Ÿå™¨ {sensor_id} çš„æ•°æ®")
            data = sensor.current_data
            return {
                'sensor_id': sensor_id,
                'temperature': data.temperature,
                'humidity': data.humidity,
                'ph_value': data.ph_value,
                'salinity': data.salinity,
                'nitrogen': data.nitrogen,
                'phosphorus': data.phosphorus,
                'potassium': data.potassium,
                'timestamp': data.timestamp
            }
        else:
            st.error(f"ä¼ æ„Ÿå™¨ {sensor_id} æœªæ‰¾åˆ°æˆ–æ— æ•°æ®")
            return {}
    
    def _validate_sensor_data(self, data: Dict) -> Dict:
        """éªŒè¯ä¼ æ„Ÿå™¨æ•°æ®"""
        warnings = []
        
        # æ•°æ®èŒƒå›´æ£€æŸ¥
        if data['temperature'] < 5 or data['temperature'] > 40:
            warnings.append("âš ï¸ æ¸©åº¦æ•°æ®è¶…å‡ºæ­£å¸¸èŒƒå›´")
        
        if data['ph_value'] < 4 or data['ph_value'] > 10:
            warnings.append("âš ï¸ pHå€¼è¶…å‡ºæ­£å¸¸èŒƒå›´")
        
        if data['salinity'] > 1.0:
            warnings.append("âš ï¸ ç›ç¢±åº¦è¾ƒé«˜")
        
        if warnings:
            for warning in warnings:
                st.warning(warning)
        else:
            st.success("âœ… æ•°æ®éªŒè¯é€šè¿‡")
        
        return data
    
    def render_sensor_status_panel(self, plot_id: str = None):
        """æ¸²æŸ“ä¼ æ„Ÿå™¨çŠ¶æ€é¢æ¿"""
        st.subheader("ğŸ“Š ä¼ æ„Ÿå™¨çŠ¶æ€ç›‘æ§")
        
        if plot_id:
            sensors = self.sensor_manager.get_sensors_by_plot(plot_id)
        else:
            sensors = list(self.sensor_manager.sensors.values())
        
        if not sensors:
            st.info("æš‚æ— ä¼ æ„Ÿå™¨æ•°æ®")
            return
        
        # çŠ¶æ€ç»Ÿè®¡
        online_count = sum(1 for s in sensors if s.status == "åœ¨çº¿")
        offline_count = len(sensors) - online_count
        
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("ä¼ æ„Ÿå™¨æ€»æ•°", len(sensors))
        with col2:
            st.metric("åœ¨çº¿è®¾å¤‡", online_count, delta=f"+{online_count}")
        with col3:
            st.metric("ç¦»çº¿è®¾å¤‡", offline_count, delta=f"-{offline_count}" if offline_count > 0 else "0")
        
        # ä¼ æ„Ÿå™¨åˆ—è¡¨
        for sensor in sensors:
            with st.expander(f"ğŸ“¡ {sensor.sensor_id} - {sensor.sensor_type}"):
                self._render_sensor_detail(sensor)
    
    def _render_sensor_detail(self, sensor: Sensor):
        """æ¸²æŸ“ä¼ æ„Ÿå™¨è¯¦æƒ…"""
        col1, col2 = st.columns(2)
        
        with col1:
            st.write(f"**çŠ¶æ€**: {sensor.status}")
            st.write(f"**ç±»å‹**: {sensor.sensor_type}")
            st.write(f"**ä½ç½®**: {sensor.plot_id} - {sensor.zone_id}")
            if sensor.last_update:
                st.write(f"**æœ€åæ›´æ–°**: {sensor.last_update.strftime('%Y-%m-%d %H:%M:%S')}")
        
        with col2:
            if sensor.current_data:
                data = sensor.current_data
                st.write("**å½“å‰æ•°æ®**:")
                st.write(f"æ¸©åº¦: {data.temperature}Â°C")
                st.write(f"æ¹¿åº¦: {data.humidity}%")
                st.write(f"pHå€¼: {data.ph_value}")
                st.write(f"ç›ç¢±åº¦: {data.salinity}â€°")
        
        # æ•°æ®è´¨é‡è¯„åˆ†
        quality_score = self.sensor_manager.get_data_quality_score(sensor.sensor_id)
        st.progress(quality_score / 100)
        st.write(f"æ•°æ®è´¨é‡è¯„åˆ†: {quality_score}/100")
    
    def render_sensor_history_chart(self, sensor_id: str, hours: int = 24):
        """æ¸²æŸ“ä¼ æ„Ÿå™¨å†å²æ•°æ®å›¾è¡¨"""
        sensor = self.sensor_manager.get_sensor(sensor_id)
        if not sensor or not sensor.data_history:
            st.info("æš‚æ— å†å²æ•°æ®")
            return
        
        # å‡†å¤‡æ•°æ®
        recent_data = [d for d in sensor.data_history 
                      if d.timestamp >= datetime.now() - timedelta(hours=hours)]
        
        if not recent_data:
            st.info(f"æœ€è¿‘{hours}å°æ—¶æ— æ•°æ®")
            return
        
        timestamps = [d.timestamp for d in recent_data]
        temperatures = [d.temperature for d in recent_data]
        humidities = [d.humidity for d in recent_data]
        ph_values = [d.ph_value for d in recent_data]
        
        # åˆ›å»ºå›¾è¡¨
        fig = go.Figure()
        
        fig.add_trace(go.Scatter(
            x=timestamps, y=temperatures,
            mode='lines+markers',
            name='æ¸©åº¦ (Â°C)',
            line=dict(color='red')
        ))
        
        fig.add_trace(go.Scatter(
            x=timestamps, y=humidities,
            mode='lines+markers',
            name='æ¹¿åº¦ (%)',
            line=dict(color='blue'),
            yaxis='y2'
        ))
        
        fig.add_trace(go.Scatter(
            x=timestamps, y=ph_values,
            mode='lines+markers',
            name='pHå€¼',
            line=dict(color='green'),
            yaxis='y3'
        ))
        
        fig.update_layout(
            title=f'ä¼ æ„Ÿå™¨ {sensor_id} å†å²æ•°æ®è¶‹åŠ¿',
            xaxis=dict(title='æ—¶é—´'),
            yaxis=dict(title='æ¸©åº¦ (Â°C)', side='left'),
            yaxis2=dict(title='æ¹¿åº¦ (%)', side='right', overlaying='y'),
            yaxis3=dict(title='pHå€¼', side='right', overlaying='y', position=0.85),
            height=400
        )
        
        st.plotly_chart(fig, use_container_width=True)
```

## éƒ¨ç½²é…ç½®

### requirements.txt
```
streamlit>=1.28.0
plotly>=5.15.0
pandas>=2.0.0
numpy>=1.24.0
folium>=0.14.0
streamlit-folium>=0.13.0
Pillow>=10.0.0
requests>=2.31.0
scikit-learn>=1.3.0
```

### å¯åŠ¨è„šæœ¬ (run.bat)
```batch
@echo off
echo å¯åŠ¨æ™ºæ’­å†œé“¾ç³»ç»Ÿ...
streamlit run app.py --server.port 8501 --server.address 0.0.0.0
pause
```

è¿™ä¸ªæŠ€æœ¯æ¶æ„è®¾è®¡ä¸º"æ™ºæ’­å†œé“¾"é¡¹ç›®æä¾›äº†å®Œæ•´çš„ä»£ç ç»“æ„å’Œç»„ä»¶è®¾è®¡æ–¹æ¡ˆï¼Œç‰¹åˆ«åŠ å¼ºäº†ä¼ æ„Ÿå™¨æ•°æ®é›†æˆåŠŸèƒ½ï¼Œç¡®ä¿é¡¹ç›®å¼€å‘çš„è§„èŒƒæ€§å’Œå¯ç»´æŠ¤æ€§ã€‚ 